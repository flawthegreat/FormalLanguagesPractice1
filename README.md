## Задача
Даны регулярное выражение в обратной польской записи `α`, буква `x` и натуральное число `n`.  
Вывести, есть ли в языке `L(α)` слова, содержащие суффикс `xⁿ`.  
Алфавит регулярного выражения: `{a, b, c, 1, ., +, *}`.
## Сборка
##### Обычная сборка
```
mkdir CMake && cd CMake
cmake ..
make
```
##### Code coverage
```
mkdir CMake && cd CMake
cmake -DCOVERAGE=true ..
make CoverageReport
```
Результат сохраняется в `Build`.
## Описание алгоритма
Будем читать регулярное выражение посимвольно. Заведем стек для сохранения информации об уже прочитанных регулярных выражениях, входящих в исходное: будем хранить длину максимального суффикса из букв `x` и длину максимального слова, полностью состоящего из `x` (`-1`, если такого слова нет). Тогда на каждом шаге:
1. Если встретили символ алфавита:
	1. Если этот символ - `1`, положим на стек `(0, 0)`.
	2. Если этот символ - `x`, положим `(1, 1)`.
	3. Иначе - `(0, -1)`.
2. Если встретили операцию `*`, снимем со стека верхний элемент:
	1. Если второе значение больше нуля то существует сколь угодно длинное слово, состоящее из `x`. Положим на стек `(∞, ∞)`.
	2. Иначе положим на стек старое значение, т.к. поскольку регулярное выражение не распознает слова, целиком состоящие из `x`, мы не можем получить такие слова в новом. Очевидно, мы не можем и удлиннить максимальный суффикс, "приклеивая" то же слово.
3. Если встретили операцию `+`, снимем со стека два верхних элемента и положим на стек элемент, состоящий из максимумов их значений.
4. Если встретили операцию `*`, снимем со стека два верхних элемента `(a, b)`и `(c, d)`:
	1. Если первое регулярное выражение не распознает слова, целиком состоящие из `x`, то улучшить значения мы не сможем, вернем на стек `(a, b)`.
	2. Иначе новое значение для максимального суффикса будет равно `max(a, c + b)`.
		1. Если второе регулярное выражение не распознает слова, целиком состоящие из `x`, то в новом регулярном выражении мы тоже не сможем распознавать такие слова.
		2. Иначе длина максимального слова будет равна `d + b`.

После рассмотрения всех символов на стеке останется один элемент `(a, b)` с ответом для исходного регулярного выражения: `L(α)` содержит `xⁿ`, если `a ≥ n`.

На каждом шаге мы снимаем не более двух элементов со стека и кладем не более одного. Время работы: `O(|α|)`.
